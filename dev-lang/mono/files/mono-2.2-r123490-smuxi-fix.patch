diff -NrU5 mono-2.2.orig/mcs/mcs/anonymous.cs mono-2.2/mcs/mcs/anonymous.cs
--- mono-2.2.orig/mcs/mcs/anonymous.cs	2009-01-26 22:23:54.000000000 +0100
+++ mono-2.2/mcs/mcs/anonymous.cs	2009-01-27 00:59:10.000000000 +0100
@@ -56,16 +56,17 @@
 	// anonymous method storey (captured)
 	//
 	public class AnonymousMethodStorey : CompilerGeneratedClass
 	{
 		class StoreyFieldPair {
-			public AnonymousMethodStorey Storey;
-			public Field Field;
+			public readonly AnonymousMethodStorey Storey;
+			public readonly Field Field;
 
-			public StoreyFieldPair (AnonymousMethodStorey storey)
+			public StoreyFieldPair (AnonymousMethodStorey storey, Field field)
 			{
 				this.Storey = storey;
+				this.Field = field;
 			}
 
 			public override int GetHashCode ()
 			{
 				return Storey.ID.GetHashCode ();
@@ -101,10 +102,11 @@
 
 		public readonly Block OriginalSourceBlock;
 
 		// A list of StoreyFieldPair with local field keeping parent storey instance
 		ArrayList used_parent_storeys;
+		ArrayList children_references;
 
 		// A list of hoisted parameters
 		protected ArrayList hoisted_params;
 		protected ArrayList hoisted_locals;
 
@@ -112,14 +114,10 @@
 		protected HoistedThis hoisted_this;
 
 		// Local variable which holds this storey instance
 		public LocalTemporary Instance;
 
-		bool references_defined;
-		bool has_hoisted_variable;
-		bool is_undone;
-
 		public AnonymousMethodStorey (Block block, DeclSpace parent, MemberBase host, GenericMethod generic, string name)
 			: base (parent, generic, MakeMemberName (host, name, generic, block.StartLocation), Modifiers.PRIVATE)
 		{
 			Parent = parent;
 			OriginalSourceBlock = block;
@@ -138,10 +136,18 @@
 			}
 
 			return new MemberName (tname, args, loc);
 		}
 
+		public void AddCapturedThisField (EmitContext ec)
+		{
+			TypeExpr type_expr = new TypeExpression (ec.ContainerType, Location);
+			Field f = AddCompilerGeneratedField ("<>f__this", type_expr);
+			f.Define ();
+			hoisted_this = new HoistedThis (this, f);
+		}
+
 		public Field AddCapturedVariable (string name, Type type)
 		{
 			CheckMembersDefined ();
 
 			FullNamedExpression field_type = new TypeExpression (type, Location);
@@ -160,104 +166,91 @@
 			Field f = new Field (this, type, mod, new MemberName (name, Location), null);
 			AddField (f);
 			return f;
 		}
 
-		public void AddParentStoreyReference (AnonymousMethodStorey s)
+		//
+		// Creates a link between block and the anonymous method storey
+		//
+		// An anonymous method can reference variables from any outer block, but they are
+		// hoisted in their own ExplicitBlock. When more than one block is referenced we
+		// need to create another link between those variable storeys
+		//
+		public void AddReferenceFromChildrenBlock (ExplicitBlock block)
+		{
+			if (children_references == null)
+				children_references = new ArrayList ();
+
+			if (!children_references.Contains (block))
+				children_references.Add (block);
+		}
+
+		public void AddParentStoreyReference (AnonymousMethodStorey storey)
 		{
 			CheckMembersDefined ();
 
 			if (used_parent_storeys == null)
 				used_parent_storeys = new ArrayList ();
-			else if (used_parent_storeys.IndexOf (s) != -1)
+			else if (used_parent_storeys.IndexOf (storey) != -1)
 				return;
 
-			has_hoisted_variable = true;
-			used_parent_storeys.Add (new StoreyFieldPair (s));
+			TypeExpr type_expr = new TypeExpression (storey.TypeBuilder, Location);
+			Field f = AddCompilerGeneratedField ("<>f__ref$" + storey.ID, type_expr);
+			used_parent_storeys.Add (new StoreyFieldPair (storey, f));
 		}
 
 		public void CaptureLocalVariable (EmitContext ec, LocalInfo local_info)
 		{
+			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
+			if (ec.CurrentBlock.Explicit != local_info.Block.Explicit)
+				AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
+
 			if (local_info.HoistedVariableReference != null)
 				return;
 
 			HoistedVariable var = new HoistedLocalVariable (this, local_info, GetVariableMangledName (local_info));
 			local_info.HoistedVariableReference = var;
-			has_hoisted_variable = true;
 
 			if (hoisted_locals == null)
 				hoisted_locals = new ArrayList ();
 
 			hoisted_locals.Add (var);
 		}
 
 		public void CaptureParameter (EmitContext ec, ParameterReference param_ref)
 		{
-			if (param_ref.HoistedVariable != null)
+			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
+			AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
+
+			if (param_ref.GetHoistedVariable (ec) != null)
 				return;
 
 			if (hoisted_params == null)
 				hoisted_params = new ArrayList (2);
 
 			HoistedVariable expr = new HoistedParameter (this, param_ref);
 			param_ref.Parameter.HoistedVariableReference = expr;
 			hoisted_params.Add (expr);
 		}
 
-		public HoistedThis CaptureThis (EmitContext ec, This t)
-		{
-			hoisted_this = new HoistedThis (this, t);
-			return hoisted_this;
-		}
-
 		public void ChangeParentStorey (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 		}
 
-		void DefineStoreyReferences ()
-		{
-			if (used_parent_storeys == null || references_defined)
-				return;
-
-			references_defined = true;
-
-			//
-			// For each used variable from parent scope we allocate its local reference point
-			//
-			for (int i = 0; i < used_parent_storeys.Count; ++i) {
-				StoreyFieldPair sf = (StoreyFieldPair) used_parent_storeys [i];
-				AnonymousMethodStorey p_storey = sf.Storey;
-				TypeExpr type_expr = new TypeExpression (p_storey.TypeBuilder, Location);
-
-				sf.Field = AddCompilerGeneratedField ("<>f__ref$" + p_storey.ID, type_expr);
-				sf.Field.Define ();
-			}
-		}
-
 		//
 		// Initializes all hoisted variables
 		//
 		public void EmitHoistedVariables (EmitContext ec)
 		{
 			// There can be only one instance variable for each storey type
 			if (Instance != null)
 				throw new InternalErrorException ();
 
-			//
-			// A storey with hoisted `this' is an instance method
-			//
-			if (!HasHoistedVariables) {
-				hoisted_this.RemoveHoisting ();
-				return;
-			}
-
 			SymbolWriter.OpenCompilerGeneratedBlock (ec.ig);
 
-			DefineStoreyReferences ();
-
 			//
 			// Create an instance of storey type
 			//
 			Expression storey_type_expr;
 			if (is_generic) {
@@ -316,10 +309,18 @@
 						a.EmitStatement (ec);
 				}
 			}
 
 			//
+			// Define hoisted `this' in top-level storey only 
+			//
+			if (OriginalSourceBlock.Explicit.HasCapturedThis && !(Parent is AnonymousMethodStorey)) {
+				AddCapturedThisField (ec);
+				hoisted_this.EmitHoistingAssignment (ec);
+			}
+
+			//
 			// Setting currect anonymous method to null blocks any further variable hoisting
 			//
 			AnonymousExpression ae = ec.CurrentAnonymousMethod;
 			ec.CurrentAnonymousMethod = null;
 
@@ -356,12 +357,10 @@
 			if (hoisted_params != null) {
 				foreach (HoistedParameter param in hoisted_params)
 					param.EmitSymbolInfo ();
 			}
 
-			DefineStoreyReferences ();
-
 			if (used_parent_storeys != null) {
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					SymbolWriter.DefineCapturedScope (ID, sf.Storey.ID, sf.Field.Name);
 				}
 			}
@@ -442,25 +441,12 @@
 			// are hoisted in their own scopes
 			//
 			return local_info.Name;
 		}
 
-		//
-		// Returns true when at least one local variable or parameter is
-		// hoisted, or story is transitioned
-		//
-		public bool HasHoistedVariables {
-			get {
-				return has_hoisted_variable || hoisted_params != null;
-			}
-			set {
-				has_hoisted_variable = value;
-			}
-		}
-
-		public bool IsUndone {
-			get { return is_undone; }
+ 		public HoistedThis HoistedThis {
+ 			get { return hoisted_this; }
 		}
 
 		//
 		// Mutate type dispatcher
 		//
@@ -584,21 +570,18 @@
 			}
 
 			return type;
 		}
 
+		public ArrayList ReferencesFromChildrenBlock {
+			get { return children_references; }
+		}
+
 		public static void Reset ()
 		{
 			unique_id = 0;
-		}
-		
-		public void Undo ()
-		{
-			is_undone = true;
-			if (hoisted_this != null)
-				hoisted_this.RemoveHoisting ();
-		}
+		}		
 	}
 
 	public abstract class HoistedVariable
 	{
 		class ExpressionTreeProxy : Expression
@@ -636,14 +619,18 @@
 		protected Field field;
 		Hashtable cached_inner_access; // TODO: Hashtable is too heavyweight
 		FieldExpr cached_outer_access;
 
 		protected HoistedVariable (AnonymousMethodStorey storey, string name, Type type)
+			: this (storey, storey.AddCapturedVariable (name, type))
 		{
-			this.storey = storey;
+		}
 
-			this.field = storey.AddCapturedVariable (name, type);
+		protected HoistedVariable (AnonymousMethodStorey storey, Field field)
+		{
+			this.storey = storey;
+			this.field = field;
 		}
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			GetFieldExpression (ec).AddressOf (ec, mode);
@@ -786,21 +773,18 @@
 		}
 	}
 
 	public class HoistedThis : HoistedVariable
 	{
-		readonly This this_reference;
-
-		public HoistedThis (AnonymousMethodStorey storey, This this_reference)
-			: base (storey, "<>f__this", this_reference.Type)
+		public HoistedThis (AnonymousMethodStorey storey, Field field)
+			: base (storey, field)
 		{
-			this.this_reference = this_reference;
 		}
 
 		public void EmitHoistingAssignment (EmitContext ec)
 		{
-			SimpleAssign a = new SimpleAssign (GetFieldExpression (ec), this_reference);
+			SimpleAssign a = new SimpleAssign (GetFieldExpression (ec), ec.GetThis (field.Location));
 			if (a.Resolve (ec) != null)
 				a.EmitStatement (ec);
 		}
 
 		public override void EmitSymbolInfo ()
@@ -809,15 +793,10 @@
 		}
 
 		public Field Field {
 			get { return field; }
 		}
-
-		public void RemoveHoisting ()
-		{
-			this_reference.RemoveHoisting ();
-		}
 	}
 
 	//
 	// Anonymous method expression as created by parser
 	//
@@ -1211,11 +1190,11 @@
 				return aec;
 			}
 
 			public override bool Define ()
 			{
-				if (Storey != null && Storey.IsGeneric && Storey.HasHoistedVariables) {
+				if (Storey != null && Storey.IsGeneric) {
 					AnonymousMethodStorey gstorey = Storey.GetGenericStorey ();
 					if (gstorey != null) {
 						if (!Parameters.IsEmpty) {
 							Type [] ptypes = Parameters.Types;
 							for (int i = 0; i < ptypes.Length; ++i)
@@ -1269,11 +1248,10 @@
 			this.ReturnType = return_type;
 			this.Block = block;
 			this.loc = loc;
 		}
 
-		public abstract void AddStoreyReference (AnonymousMethodStorey storey);
 		public abstract string ContainerType { get; }
 		public abstract bool IsIterator { get; }
 		public abstract AnonymousMethodStorey Storey { get; }
 
 		public bool Compatible (EmitContext ec)
@@ -1315,15 +1293,28 @@
 				aec_dispose.Dispose ();
 			}
 
 			return res;
 		}
+
+		public void SetHasThisAccess ()
+		{
+			Block.HasCapturedThis = true;
+			ExplicitBlock b = Block.Parent.Explicit;
+
+			while (b != null) {
+				if (b.HasCapturedThis)
+					return;
+
+				b.HasCapturedThis = true;
+				b = b.Parent == null ? null : b.Parent.Explicit;
+			}
+		}
 	}
 
 	public class AnonymousMethodBody : AnonymousExpression
 	{
-		ArrayList referenced_storeys;
 		protected readonly Parameters parameters;
 		AnonymousMethodStorey storey;
 
 		AnonymousMethodMethod method;
 		Field am_cache;
@@ -1349,27 +1340,10 @@
 
 		public override bool IsIterator {
 			get { return false; }
 		}
 
-		//
-		// Adds new storey reference to track out of scope variables
-		//
-		public override void AddStoreyReference (AnonymousMethodStorey storey)
-		{
-			if (referenced_storeys == null) {
-				referenced_storeys = new ArrayList (2);
-			} else {
-				foreach (AnonymousMethodStorey ams in referenced_storeys) {
-					if (ams == storey)
-						return;
-				}
-			}
-
-			referenced_storeys.Add (storey);
-		}
-
 		public override Expression CreateExpressionTree (EmitContext ec)
 		{
 			Report.Error (1945, loc, "An expression tree cannot contain an anonymous method expression");
 			return null;
 		}
@@ -1377,37 +1351,13 @@
 		bool Define (EmitContext ec)
 		{
 			if (aec == null && !Compatible (ec))
 				return false;
 
-			if (referenced_storeys != null)
-				ConnectReferencedStoreys ();
-
 			return true;
 		}
 
-		void ConnectReferencedStoreys ()
-		{
-			storey = FindBestMethodStorey ();
-
-			foreach (AnonymousMethodStorey s in referenced_storeys) {
-				//
-				// An anonymous method has to have an instance access when
-				// children anonymous method requires access to parent storey
-				// hoisted variables
-				//
-				for (Block b = Block.Parent; b != s.OriginalSourceBlock; b = b.Parent)
-					b.Toplevel.HasStoreyAccess = true;
-
-				if (s == storey)
-					continue;
-
-				s.HasHoistedVariables = true;
-				Block.Parent.Explicit.PropagateStoreyReference (s);
-			}
-		}
-
 		//
 		// Creates a host for the anonymous method
 		//
 		AnonymousMethodMethod DoCreateMethodHost (EmitContext ec)
 		{
@@ -1418,14 +1368,12 @@
 			// 2, a static method in current scope when neither `this' nor any variable is hoisted
 			// 3, an instance method in compiler generated storey when any hoisted variable exists
 			//
 
 			int modifiers;
-			if (referenced_storeys != null || Block.HasStoreyAccess) {
-				if (storey == null || storey.IsUndone)
-					storey = FindBestMethodStorey ();
-
+			if (Block.HasCapturedVariable || Block.HasCapturedThis) {
+				storey = FindBestMethodStorey ();
 				modifiers = storey != null ? Modifiers.INTERNAL : Modifiers.PRIVATE;
 			} else {
 				if (ec.CurrentAnonymousMethod != null)
 					storey = ec.CurrentAnonymousMethod.Storey;
 
diff -NrU5 mono-2.2.orig/mcs/mcs/ChangeLog mono-2.2/mcs/mcs/ChangeLog
--- mono-2.2.orig/mcs/mcs/ChangeLog	2009-01-27 00:55:28.000000000 +0100
+++ mono-2.2/mcs/mcs/ChangeLog	2009-01-27 01:02:52.000000000 +0100
@@ -1,6 +1,12 @@
-2009-01-27 Peter Alfredsen <loki_val@gentoo.org>
+2009-01-27  Peter Alfredsen <loki_val@gentoo.org>
+	Backport of
+	2009-01-15  Marek Safar  <marek.safar@gmail.com>
+		* iterators.cs, anonymous.cs, expression.cs, statement.cs, ecore.cs:
+		Fixed nested stories parent referencing process. Also fixes #463985.
+
+2009-01-27  Peter Alfredsen <loki_val@gentoo.org>
 	Backport of
 	2008-11-11  Marek Safar  <marek.safar@gmail.com>
 	 	A fix for bug #435747
 		* assign.cs, expression.cs: Cleanup New assignment to emit correcly
 		compound value types assignment. Few micro optimizations added.
diff -NrU5 mono-2.2.orig/mcs/mcs/ecore.cs mono-2.2/mcs/mcs/ecore.cs
--- mono-2.2.orig/mcs/mcs/ecore.cs	2009-01-26 22:23:54.000000000 +0100
+++ mono-2.2/mcs/mcs/ecore.cs	2009-01-27 00:59:10.000000000 +0100
@@ -5895,12 +5895,13 @@
 		public void EmitAssign (EmitContext ec, Expression source)
 		{
 			EmitAssign (ec, source, false, false);
 		}
 
-		public override HoistedVariable HoistedVariable {
-			get { return li.HoistedVariableReference; }
+		public override HoistedVariable GetHoistedVariable (EmitContext ec)
+		{
+			return li.HoistedVariableReference;
 		}
 
 		public override bool IsFixed {
 			get { return true; }
 		}
diff -NrU5 mono-2.2.orig/mcs/mcs/expression.cs mono-2.2/mcs/mcs/expression.cs
--- mono-2.2.orig/mcs/mcs/expression.cs	2009-01-27 00:55:28.000000000 +0100
+++ mono-2.2/mcs/mcs/expression.cs	2009-01-27 01:00:39.000000000 +0100
@@ -4034,11 +4034,11 @@
 
 	public abstract class VariableReference : Expression, IAssignMethod, IMemoryLocation, IVariableReference {
 		LocalTemporary temp;
 
 		#region Abstract
-		public abstract HoistedVariable HoistedVariable { get; }
+		public abstract HoistedVariable GetHoistedVariable (EmitContext ec);
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
@@ -4053,12 +4053,13 @@
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
-			if (IsHoistedEmitRequired (ec)) {
-				HoistedVariable.AddressOf (ec, mode);
+			HoistedVariable hv = GetHoistedVariable (ec);
+			if (hv != null) {
+				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
@@ -4086,12 +4087,13 @@
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
-			if (IsHoistedEmitRequired (ec)) {
-				HoistedVariable.Emit (ec, leave_copy);
+			HoistedVariable hv = GetHoistedVariable (ec);
+			if (hv != null) {
+				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
@@ -4114,12 +4116,13 @@
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
-			if (IsHoistedEmitRequired (ec)) {
-				HoistedVariable.EmitAssign (ec, source, leave_copy, prepare_for_load);
+			HoistedVariable hv = GetHoistedVariable (ec);
+			if (hv != null) {
+				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
@@ -4153,19 +4156,11 @@
 				temp.Release (ec);
 			}
 		}
 
 		public bool IsHoisted {
-			get { return HoistedVariable != null; }
-		}
-
-		protected virtual bool IsHoistedEmitRequired (EmitContext ec)
-		{
-			//
-			// Default implementation return true when there is a hosted variable
-			//
-			return HoistedVariable != null;
+			get { return GetHoistedVariable (null) != null; }
 		}
 
 		public override void MutateHoistedGenericType (AnonymousMethodStorey storey)
 		{
 			type = storey.MutateType (type);
@@ -4203,12 +4198,13 @@
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
-		public override HoistedVariable HoistedVariable {
-			get { return local_info.HoistedVariableReference; }
+		public override HoistedVariable GetHoistedVariable (EmitContext ec)
+		{
+			return local_info.HoistedVariableReference;
 		}
 
 		//		
 		// A local variable is always fixed
 		//
@@ -4390,12 +4386,13 @@
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
-		public override HoistedVariable HoistedVariable {
-			get { return pi.Parameter.HoistedVariableReference; }
+		public override HoistedVariable GetHoistedVariable (EmitContext ec)
+		{
+			return pi.Parameter.HoistedVariableReference;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
@@ -4496,12 +4493,13 @@
 			// Nothing to clone
 		}
 
 		public override Expression CreateExpressionTree (EmitContext ec)
 		{
-			if (IsHoistedEmitRequired (ec))
-				return HoistedVariable.CreateExpressionTree (ec);
+			HoistedVariable hv = GetHoistedVariable (ec);
+			if (hv != null)
+				return hv.CreateExpressionTree (ec);
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
@@ -6521,12 +6519,13 @@
 			if (type == null)
 				type = ec.ContainerType;
 			return this;
 		}
 
-		public override HoistedVariable HoistedVariable {
-			get { return null; }
+		public override HoistedVariable GetHoistedVariable (EmitContext ec)
+		{
+			return null;
 		}
 	}
 	
 	/// <summary>
 	///   Represents the `this' construct
@@ -6575,40 +6574,39 @@
 
 		public override bool IsFixed {
 			get { return false; }
 		}
 
-		protected override bool IsHoistedEmitRequired (EmitContext ec)
+		public override HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
-			//
-			// Handle 'this' differently, it cannot be assigned hence
-			// when we are not inside anonymous method we can emit direct access 
-			//
-			return ec.CurrentAnonymousMethod != null && base.IsHoistedEmitRequired (ec);
-		}
+			// Is null when probing IsHoisted
+			if (ec == null)
+				return null;
+
+			if (ec.CurrentAnonymousMethod == null)
+				return null;
+
+			AnonymousMethodStorey storey = ec.CurrentAnonymousMethod.Storey;
+			while (storey != null) {
+				AnonymousMethodStorey temp = storey.Parent as AnonymousMethodStorey;
+				if (temp == null)
+					return storey.HoistedThis;
 
-		public override HoistedVariable HoistedVariable {
-			get { return TopToplevelBlock.HoistedThisVariable; }
+				storey = temp;
+			}
+
+			return null;
 		}
 
 		public override bool IsRef {
 			get { return is_struct; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return ThisVariable.Instance; }
 		}
 
-		// TODO: Move to ToplevelBlock
-		ToplevelBlock TopToplevelBlock {
-			get {
-				ToplevelBlock tl = block.Toplevel;
-				while (tl.Parent != null) tl = tl.Parent.Toplevel;
-				return tl;
-			}
-		}
-
 		public static bool IsThisAvailable (EmitContext ec)
 		{
 			if (ec.IsStatic || ec.IsInFieldInitializer)
 				return false;
 
@@ -6648,28 +6646,12 @@
 			if (block != null) {
 				if (block.Toplevel.ThisVariable != null)
 					variable_info = block.Toplevel.ThisVariable.VariableInfo;
 
 				AnonymousExpression am = ec.CurrentAnonymousMethod;
-				if (am != null) {
-					//
-					// this is hoisted to very top level block
-					//
-					if (ec.IsVariableCapturingRequired) {
-						//
-						// TODO: it should be optimized, see test-anon-75.cs
-						//
-						// `this' variable has its own scope which is mostly empty
-						// and causes creation of extraneous storey references.
-						// Also it's hard to remove `this' dependencies when we Undo
-						// this access.
-						//
-						AnonymousMethodStorey scope = TopToplevelBlock.Explicit.CreateAnonymousMethodStorey (ec);
-						if (HoistedVariable == null) {
-							TopToplevelBlock.HoistedThisVariable = scope.CaptureThis (ec, this);
-						}
-					}
+				if (am != null && ec.IsVariableCapturingRequired) {
+					am.SetHasThisAccess ();
 				}
 			}
 			
 			return true;
 		}
@@ -6754,15 +6736,10 @@
 			This target = (This) t;
 
 			target.block = clonectx.LookupBlock (block);
 		}
 
-		public void RemoveHoisting ()
-		{
-			TopToplevelBlock.HoistedThisVariable = null;
-		}
-
 		public override void SetHasAddressTaken ()
 		{
 			// Nothing
 		}
 	}
diff -NrU5 mono-2.2.orig/mcs/mcs/iterators.cs mono-2.2/mcs/mcs/iterators.cs
--- mono-2.2.orig/mcs/mcs/iterators.cs	2009-01-26 22:23:54.000000000 +0100
+++ mono-2.2/mcs/mcs/iterators.cs	2009-01-27 00:59:10.000000000 +0100
@@ -399,11 +399,10 @@
 		public IteratorStorey (Iterator iterator)
 			: base (iterator.Container.Toplevel, iterator.Host,
 			  iterator.OriginalMethod as MemberBase, iterator.GenericMethod, "Iterator")
 		{
 			this.Iterator = iterator;
-			HasHoistedVariables = true;
 		}
 
 		public Field PC {
 			get { return pc_field; }
 		}
@@ -647,15 +646,10 @@
 			Uninitialized = -2,
 			After = -1,
 			Start = 0
 		}
 
-		public override void AddStoreyReference (AnonymousMethodStorey storey)
-		{
-			// do nothing
-		}
-
 		public void EmitYieldBreak (ILGenerator ig, bool unwind_protect)
 		{
 			ig.Emit (unwind_protect ? OpCodes.Leave : OpCodes.Br, move_next_error);
 		}
 
diff -NrU5 mono-2.2.orig/mcs/mcs/statement.cs mono-2.2/mcs/mcs/statement.cs
--- mono-2.2.orig/mcs/mcs/statement.cs	2009-01-26 22:23:54.000000000 +0100
+++ mono-2.2/mcs/mcs/statement.cs	2009-01-27 00:59:10.000000000 +0100
@@ -1518,13 +1518,14 @@
 			Unchecked = 1,
 			BlockUsed = 2,
 			VariablesInitialized = 4,
 			HasRet = 8,
 			IsDestructor = 16,
-			Unsafe = 32,
-			IsIterator = 64,
-			HasStoreyAccess	= 128
+			Unsafe = 16,
+			IsIterator = 32,
+			HasCapturedVariable = 64,
+			HasCapturedThis = 128
 		}
 		protected Flags flags;
 
 		public bool Unchecked {
 			get { return (flags & Flags.Unchecked) != 0; }
@@ -2454,11 +2455,10 @@
 		{
 			//
 			// When referencing a variable in iterator storey from children anonymous method
 			//
 			if (Toplevel.am_storey is IteratorStorey) {
-				ec.CurrentAnonymousMethod.AddStoreyReference (Toplevel.am_storey);
 				return Toplevel.am_storey;
 			}
 
 			//
 			// An iterator has only 1 storey block
@@ -2469,23 +2469,15 @@
 			if (am_storey == null) {
 				MemberBase mc = ec.ResolveContext as MemberBase;
 				GenericMethod gm = mc == null ? null : mc.GenericMethod;
 
 				//
-				// Create anonymous method storey for this block
+				// Creates anonymous method storey for this block
 				//
 				am_storey = new AnonymousMethodStorey (this, ec.TypeContainer, mc, gm, "AnonStorey");
 			}
 
-			//
-			// Creates a link between this block and the anonymous method
-			//
-			// An anonymous method can reference variables from any outer block, but they are
-			// hoisted in their own ExplicitBlock. When more than one block is referenced we
-			// need to create another link between those variable storeys
-			//
-			ec.CurrentAnonymousMethod.AddStoreyReference (am_storey);
 			return am_storey;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
@@ -2511,46 +2503,51 @@
 				if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.Storey != null) {
 					am_storey.ChangeParentStorey (ec.CurrentAnonymousMethod.Storey);
 				}
 
 				am_storey.DefineType ();
-				am_storey.ResolveType ();				
+				am_storey.ResolveType ();
 				am_storey.Define ();
 				am_storey.Parent.PartialContainer.AddCompilerGeneratedClass (am_storey);
+
+				ArrayList ref_blocks = am_storey.ReferencesFromChildrenBlock;
+				if (ref_blocks != null) {
+					foreach (ExplicitBlock ref_block in ref_blocks) {
+						for (ExplicitBlock b = ref_block.Explicit; b != this; b = b.Parent.Explicit) {
+						    if (b.am_storey != null) {
+						        b.am_storey.AddParentStoreyReference (am_storey);
+
+								// Stop propagation inside same top block
+								if (b.Toplevel == Toplevel)
+									break;
+
+								b = b.Toplevel;
+						    }
+							b.HasCapturedVariable = true;
+						}
+					}
+				}
 			}
 
 			base.EmitMeta (ec);
 		}
 
 		internal IKnownVariable GetKnownVariable (string name)
 		{
 			return known_variables == null ? null : (IKnownVariable) known_variables [name];
 		}
 
-		public void PropagateStoreyReference (AnonymousMethodStorey s)
+		public bool HasCapturedThis
 		{
-			if (Parent != null && am_storey != s) {
-				if (am_storey != null)
-					am_storey.AddParentStoreyReference (s);
-
-				Parent.Explicit.PropagateStoreyReference (s);
-			}
+			set { flags = value ? flags | Flags.HasCapturedThis : flags & ~Flags.HasCapturedThis; }
+			get { return (flags & Flags.HasCapturedThis) != 0; }
 		}
 
-		public override bool Resolve (EmitContext ec)
+		public bool HasCapturedVariable
 		{
-			bool ok = base.Resolve (ec);
-
-			//
-			// Discard an anonymous method storey when this block has no hoisted variables
-			//
-			if (am_storey != null && !am_storey.HasHoistedVariables) {
-				am_storey.Undo ();
-				am_storey = null;
-			}
-
-			return ok;
+			set { flags = value ? flags | Flags.HasCapturedVariable : flags & ~Flags.HasCapturedVariable; }
+			get { return (flags & Flags.HasCapturedVariable) != 0; }
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			ExplicitBlock target = (ExplicitBlock) t;
@@ -2612,15 +2609,10 @@
 
 		public GenericMethod GenericMethod {
 			get { return generic; }
 		}
 
-		public bool HasStoreyAccess {
-			set { flags = value ? flags | Flags.HasStoreyAccess : flags & ~Flags.HasStoreyAccess; }
-			get { return (flags & Flags.HasStoreyAccess) != 0;  }
-		}
-
 		public ToplevelBlock Container {
 			get { return Parent == null ? null : Parent.Toplevel; }
 		}
 
 		public ToplevelBlock (Block parent, Parameters parameters, Location start) :
